# 前端知识体系



## JavaScript

### 背景

#### 什么是JavaScript？

JavaScript 最初被创建的目的是“使网页更生动”。

这种编程语言写出来的程序被称为**脚本**。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。

脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。

#### 为什么要叫JavaScript？

因为当时Java很火，叫Java的弟弟可以有利发展，说白了就是蹭热度

### 数据类型以及常用Api

#### Number - 基本数据类型

`typeof 1 = 'number'`

#### String - 基本数据类型

`typeof 'str' = 'string'`

#### Boolean - 基本数据类型

`typeof true = 'boolean'`

#### Null - 基本数据类型

`typeof null = 'object'`

js第一版的设计中判断有问题，`null`被判断成了`object`。ES6有提案修复，但被否决了，所以现在不是bug，得当成一个feature了....

![image-20201115120529981](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115120529981.png)

#### Undefined - 基本数据类型

`typeof undefined = 'undefined'`

#### Object - 引用数据类型

`typeof {} = 'object'`

#### 关于Function、Array

`typeof (() => {}) = 'function'`

`typeof [] = 'object'`

这里有两个注意点：

- `function`对象与普通对象相比，其内部有一个`[[Call]]`方法，用来表示这个对象是可调用的，`typeof`操作符在判断Object时，如果内部实现了`[[Call]]`方法,就返回`'function'`
- 数组返回的也是`object`，所以不能用`typeof`来判断数组，可以用`instanceof`、`Array.isArray`来判断是否为数组

#### 扩展：判断一个变量的类型？

通过上面的`typepf`操作符我们可以发现，数组、null、object都是 'object'，所以用`typeof`来判断并不是很优雅，判断完之后还要再用别的方式再进行过判断。所以最好是利用Object对象的`toString`方法。它会返回一个`'[object xxxx]'`的字符串：

| 类型                                      | 返回值               |
| ----------------------------------------- | -------------------- |
| Object.prototype.toString.call(1)         | "[object Number]"    |
| Object.prototype.toString.call("")        | "[object String]"    |
| Object.prototype.toString.call(true)      | "[object Boolean]"   |
| Object.prototype.toString.call(null)      | "[object Null]"      |
| Object.prototype.toString.call(undefined) | "[object Undefined]" |
| Object.prototype.toString.call(() => {})  | "[object Function]"  |
| Object.prototype.toString.call([])        | "[object Array]"     |
| Object.prototype.toString.call(Symbol())  | "[object Symbol]"    |

为什么要通过`call`来调用？因为很多类型内部都重写了`toString`方法，比如String，调用toString是输出字符串本身，所以要通过`call`来调用

### ES6、ES7新特性

#### 关于ECMAScript

#### let const - 新的变量声明方式

先说说`var`声明变量的痛点:

- 变量提升：一个没有声明的变量打印不应该报错么？会造成疑惑
- 没有块级作用域（除了函数）：变量污染，这在某些情况下会是灾难
- 允许重复声明：变量会被覆盖，这种在编译环节就应该暴露的问题可能会暴露到生产环境

![image-20201115122020582](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115122020582.png)

因此，使用`let` `const`是很有必要的

`let`：

- 有暂时性死区，不会被提升

- 作用域是块级的
- 不能重复声明已存在的变量

`const`:

- 只能声明，不能赋值：一般用于常量
- 其他与let类似

##### 扩展：关于变量提升

推荐一篇文章：https://zhuanlan.zhihu.com/p/28140450，关于暂时死区和变量提升相关的讲的比较深入

#### 箭头函数

箭头函数和普通函数的区别：

- 写法上：() => {}，不需要`function`声明
- `this`处理：普通函数执行时绑定`this`，箭头函数是声明时就绑定`this`,且箭头函数的`this`不能改变
- 不能作为构造函数，不能使用`new`关键字
- 没有`arguments`
- 没有`prototype`

#### generator async\await - 异步解决方案

`Promise`的链式调用写法上不优雅，`generator`、`async\await`在写法上，将异步的方式以同步代码书写方式表现出来，更加容易理解且优雅

### Event Loop

## CSS

## HTML

## 计算机网络

### HTTP缓存

### HTTPS

## 数据结构

## 算法

## 框架

### react

## Koa

