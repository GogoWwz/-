# 前端知识体系



## JavaScript

### 背景

#### 什么是JavaScript？

JavaScript 最初被创建的目的是“使网页更生动”。

这种编程语言写出来的程序被称为**脚本**。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。

脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。

#### 为什么要叫JavaScript？

因为当时Java很火，叫Java的脚本可以有利发展，现在的话讲就是蹭热度

### 数据类型以及常用Api

#### Number - 基本数据类型

`typeof 1 = 'number'`

#### String - 基本数据类型

`typeof 'str' = 'string'`

- charAt

  返回指定下标的字符

- concat

  拼接字符串

- slice

  返回截取的字符串，第一个参数为起始下标，第二个参数为终点下标，含头不含尾，不修改原字符串

- substr

  返回截取的字符串，第一个参数为起始下标，第二个参数为终点下标，含头不含尾，不修改原字符串

- substring

  返回截取的字符串，第一个参数为起始下标，第二个参数截取字符个数，不修改原字符串

#### Boolean - 基本数据类型

`typeof true = 'boolean'`

#### Null - 基本数据类型

`typeof null = 'object'`

js第一版的设计中判断有问题，`null`被判断成了`object`。ES6有提案修复，但被否决了，所以现在不是bug，得当成一个feature了....

![image-20201115120529981](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115120529981.png)

#### Undefined - 基本数据类型

`typeof undefined = 'undefined'`

#### Object - 引用数据类型

`typeof {} = 'object'`

#### 关于Function、Array

`typeof (() => {}) = 'function'`

`typeof [] = 'object'`

这里有两个注意点：

- `function`对象与普通对象相比，其内部有一个`[[Call]]`方法，用来表示这个对象是可调用的，`typeof`操作符在判断Object时，如果内部实现了`[[Call]]`方法,就返回`'function'`
- 数组返回的也是`object`，所以不能用`typeof`来判断数组，可以用`instanceof`、`Array.isArray`来判断是否为数组

#### 扩展：判断一个变量的类型？

通过上面的`typepf`操作符我们可以发现，数组、null、object都是 'object'，所以用`typeof`来判断并不是很优雅，判断完之后还要再用别的方式再进行过判断。所以最好是利用Object对象的`toString`方法。它会返回一个`'[object xxxx]'`的字符串：

| 类型                                                 | 返回值                       |
| ---------------------------------------------------- | ---------------------------- |
| Object.prototype.toString.call(1)                    | "[object Number]"            |
| Object.prototype.toString.call("")                   | "[object String]"            |
| Object.prototype.toString.call(true)                 | "[object Boolean]"           |
| Object.prototype.toString.call(null)                 | "[object Null]"              |
| Object.prototype.toString.call(undefined)            | "[object Undefined]"         |
| Object.prototype.toString.call(() => {})             | "[object Function]"          |
| Object.prototype.toString.call([])                   | "[object Array]"             |
| Object.prototype.toString.call(Symbol())             | "[object Symbol]"            |
| Object.prototype.toString.call((async () => {}))     | "[object AsyncFunction]"     |
| Object.prototype.toString.call((function *fun() {})) | "[object GeneratorFunction]" |

为什么要通过`call`来调用？因为很多类型内部都重写了`toString`方法，比如String，调用toString是输出字符串本身，所以要通过`call`来调用

### ES6、ES7新特性

#### 关于ECMAScript

#### let const - 新的变量声明方式

先说说`var`声明变量的痛点:

- 变量提升：一个没有声明的变量打印不应该报错么？会造成疑惑
- 没有块级作用域（除了函数）：变量污染，这在某些情况下会是灾难
- 允许重复声明：变量会被覆盖，这种在编译环节就应该暴露的问题可能会暴露到生产环境

![image-20201115122020582](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115122020582.png)

因此，使用`let` `const`是很有必要的

`let`：

- 有暂时性死区，不会被提升

- 作用域是块级的
- 不能重复声明已存在的变量

`const`:

- 只能声明，不能赋值：一般用于常量
- 其他与let类似

##### 扩展：关于变量提升以及暂时死区

推荐一篇文章：https://zhuanlan.zhihu.com/p/28140450

#### 箭头函数

箭头函数和普通函数的区别：

- 写法上：() => {}，不需要`function`声明
- `this`处理：普通函数执行时绑定`this`，箭头函数是声明时就绑定`this`,且箭头函数的`this`不能改变
- 不能作为构造函数，不能使用`new`关键字
- 没有`arguments`
- 没有`prototype`

#### Promise对象

#### generator函数

`Promise`的链式调用写法上不优雅，`generator`在写法上，将异步的方式以同步代码书写方式表现出来，增加了可读性

#### async\await

可以看出来，`Promise`、`generator`、`async\await`都是为了优雅的解决异步问题的

三者关系可以理解为：`generator`是`Promise`和`async\await`的中间版，`async\await`是`generator`的语法糖

#### Set

#### Symbol

#### Map

`Map`对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值

与对象的区别：

![image-20201115195426037](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115195426037.png)

属性和api：

- `size`：获取map的长度，`map.size`
- `set`：设置键值对,`map.set(key, val)`
- `get`：返回指定键的值，`map.get(key)`，如果不存在，返回`undefined`
- `has`：判断是否包含某个键值对，`map.has(key)`
- `keys`：返回按插入顺序排序的键的对象，`map.keys()`，格式形如`{ "key1", "key2" }`
- `values`: 返回按插入顺序排序的值的对象，`map.values()`，格式形如`{ "value1", "value" }`
- `delete`：删除指定键值对，`map.delete(key)`
- `clear`：清空map，`map.clear()`
- `forEach`: 遍历map，`map.forEach((value, key) => {})`

#### WeakMap

WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的

属性和api：



#### 扩展：判断一个函数为generaotr函数或者async函数？

`Object.prototype.toString.call`方法，generaotr返回："[object GeneratorFunction]"

`Object.prototype.toString.call`方法，async返回："[object AsyncFunction]"

#### 扩展：Promise中的reject catch和try catch区别

这个实际上问的本质是执行环境栈、宏任务、微任务的错误捕获问题

我们都知道[Event Loop](###Event Loop)，因为我们的代码可能会在三个地方报错，所以有不同的捕获方式：

| 任务类型                 | 捕获方式                                        |
| ------------------------ | ----------------------------------------------- |
| 执行环境栈（call stack） | `try catch`、`window.onerror`                   |
| 宏任务（macrotask）      | `window.onerror`                                |
| 微任务（microtask）      | `window.addEventListener('unhandledrejection')` |

```javascript
	function stack() {
        throw new Error("执行环境栈报错")
    }
    function macroTask() {
        setTimeout(() => {
            throw new Error("宏任务报错")
        }, 0)
    }
    function microTask() {
        Promise.reject("微任务报错")
    }
    window.onerror = function () {
        console.log(...arguments)
    }
    window.addEventListener("unhandledrejection", (err) => {
        console.log(err)
    })
    macroTask()
    microTask()
    stack()
```

#### 扩展：async\await 中的错误处理

最直接的肯定是`try catch`捕获

但是当有多个异步时，就会有很多`try catch`了，所以可以通过将`async`函数用`promise`再封装一层，`resolve` `reject`返回一个数组`[error, data]`，再在外层进行判断是否有`error`分别处理

```javascript
// to.js
export default function to(promise) {
    return promise
        .then(data => {
            return [null, data];
        })
        .catch(err => [err]);
}

// 使用
import to from "./to.js";
async function asyncTask(cb) {
    let err, user, savedTask;

    [err, user] = await to(UserModel.findById(1));
    if (!user) return cb("No user found");

    [err, savedTask] = await to(TaskModel({ userId: user.id, name: "Demo Task" }));
    if (err) return cb("Error occurred while saving task");

    if (user.notificationsEnabled) {
        const [err] = await to(NotificationService.sendNotification(user.id, "Task Created"));
        if (err) return cb("Error while sending notification");
    }

    cb(null, savedTask);
}
```

#### 扩展：Map和WeakMap的区别

- 属性和方法不同：WeakMap没有`size`、`clear`、`forEach`等属性或方法
- 键值区别：WeakMap键值必须为对象，不能为基本数据类型
- 强弱引用区别：WeakMap中键是弱引用的，Map中键是强引用的

关于这两个的强弱引用，我们可以先看两张图：

**WeakMap**

![image-20201115215342615](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115215342615.png)

**Map**

![image-20201115215558451](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115215558451.png)

第一张是WeakMap的，第二张是Map的，并且Map的size一直有

可以看到，WeakMap中的obj键，在obj这个变量指为null 8s之后，WeakMap就把以obj这个对象的键值对清了；

反之，Map中，则一直保持着obj这个对象的引用，并没有被清



透过现象挖掘本质，这就是强弱引用的区别：

JavaScript的垃圾回收机制：当一个变量不被引用的时候，这片内存就会被回收。

像Object、Map中的键对某个变量的引用为强引用，即使某个变量被释放了，如果这俩玩意儿的键值依然引用着这片地址，那么该变量实际的内存是不会被回收的，这就是强引用。

而WeakMap中的键引用的变量，垃圾回收机制不会考虑你引用了这片内存，过一段时间之后，就会被回收了，这就是弱引用。

什么时候用WeakMap呢？



### 面向对象

#### 原型链 

#### 继承

### Event Loop

## CSS

## HTML

## 计算机网络

### 计算机网络模型

#### OSI参考模型（7层）

应用层、表示层、会话层 、传输层、网络层、数据链路层、物理层

#### TCP/IP参考模型（4层）

应用层、传输层、网络层、数据链路层

#### 5层参考模型

应用层、传输层、网络层、数据链路层、物理层

### HTTP缓存

### HTTPS

### WEB存储

## 数据结构

## 算法

#### 动态规划

这类题目看到之后，先分析状态转移方程

## 设计模式

### 观察者模式

当对象间存在一对多关系时，则使用观察者模式（`Observer Pattern`）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

就像老师上课布置作业

### 发布\订阅模式

### 工厂模式

### 单例模式

## 框架

### react

## 前端工程化

## Node

#### 架构



### Koa