# 前端知识体系



## JavaScript

### 背景

#### 什么是JavaScript？

JavaScript 最初被创建的目的是“使网页更生动”。

这种编程语言写出来的程序被称为**脚本**。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。

脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。

#### 为什么要叫JavaScript？

因为当时Java很火，叫Java的脚本可以有利发展，现在的话讲就是蹭热度

### 数据类型以及常用Api

#### Number - 基本数据类型

`typeof 1 = 'number'`

#### String - 基本数据类型

`typeof 'str' = 'string'`

- charAt

  返回指定下标的字符

- concat

  拼接字符串

- slice

  返回截取的字符串，第一个参数为起始下标，第二个参数为终点下标，含头不含尾，不修改原字符串

- substr

  返回截取的字符串，第一个参数为起始下标，第二个参数为终点下标，含头不含尾，不修改原字符串

- substring

  返回截取的字符串，第一个参数为起始下标，第二个参数截取字符个数，不修改原字符串

#### Boolean - 基本数据类型

`typeof true = 'boolean'`

#### Null - 基本数据类型

`typeof null = 'object'`

js第一版的设计中判断有问题，`null`被判断成了`object`。ES6有提案修复，但被否决了，所以现在不是bug，得当成一个feature了....

![image-20201115120529981](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115120529981.png)

#### Undefined - 基本数据类型

`typeof undefined = 'undefined'`

#### Object - 引用数据类型

`typeof {} = 'object'`

#### 关于Function、Array

`typeof (() => {}) = 'function'`

`typeof [] = 'object'`

这里有两个注意点：

- `function`对象与普通对象相比，其内部有一个`[[Call]]`方法，用来表示这个对象是可调用的，`typeof`操作符在判断Object时，如果内部实现了`[[Call]]`方法,就返回`'function'`
- 数组返回的也是`object`，所以不能用`typeof`来判断数组，可以用`instanceof`、`Array.isArray`来判断是否为数组

#### 扩展：判断一个变量的类型？

通过上面的`typepf`操作符我们可以发现，数组、null、object都是 'object'，所以用`typeof`来判断并不是很优雅，判断完之后还要再用别的方式再进行过判断。所以最好是利用Object对象的`toString`方法。它会返回一个`'[object xxxx]'`的字符串：

| 类型                                                 | 返回值                       |
| ---------------------------------------------------- | ---------------------------- |
| Object.prototype.toString.call(1)                    | "[object Number]"            |
| Object.prototype.toString.call("")                   | "[object String]"            |
| Object.prototype.toString.call(true)                 | "[object Boolean]"           |
| Object.prototype.toString.call(null)                 | "[object Null]"              |
| Object.prototype.toString.call(undefined)            | "[object Undefined]"         |
| Object.prototype.toString.call(() => {})             | "[object Function]"          |
| Object.prototype.toString.call([])                   | "[object Array]"             |
| Object.prototype.toString.call(Symbol())             | "[object Symbol]"            |
| Object.prototype.toString.call((async () => {}))     | "[object AsyncFunction]"     |
| Object.prototype.toString.call((function *fun() {})) | "[object GeneratorFunction]" |

为什么要通过`call`来调用？因为很多类型内部都重写了`toString`方法，比如String，调用toString是输出字符串本身，所以要通过`call`来调用

### ES6、ES7新特性

#### 关于ECMAScript

#### let const - 新的变量声明方式

先说说`var`声明变量的痛点:

- 变量提升：一个没有声明的变量打印不应该报错么？会造成疑惑
- 没有块级作用域（除了函数）：变量污染，这在某些情况下会是灾难
- 允许重复声明：变量会被覆盖，这种在编译环节就应该暴露的问题可能会暴露到生产环境

![image-20201115122020582](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115122020582.png)

因此，使用`let` `const`是很有必要的

`let`：

- 有暂时性死区，不会被提升

- 作用域是块级的
- 不能重复声明已存在的变量

`const`:

- 只能声明，不能赋值：一般用于常量
- 其他与let类似

##### 扩展：关于变量提升以及暂时死区

推荐一篇文章：https://zhuanlan.zhihu.com/p/28140450

#### 箭头函数

箭头函数和普通函数的区别：

- 写法上：() => {}，不需要`function`声明
- `this`处理：普通函数执行时绑定`this`，箭头函数是声明时就绑定`this`,且箭头函数的`this`不能改变
- 不能作为构造函数，不能使用`new`关键字
- 没有`arguments`
- 没有`prototype`

#### Promise对象

#### generator函数

`Promise`的链式调用写法上不优雅，`generator`在写法上，将异步的方式以同步代码书写方式表现出来，增加了可读性

#### async\await

可以看出来，`Promise`、`generator`、`async\await`都是为了优雅的解决异步问题的

三者关系可以理解为：`generator`是`Promise`和`async\await`的中间版，`async\await`是`generator`的语法糖

#### Set

#### Symbol

#### Map

`Map`对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值

与对象的区别：

![image-20201115195426037](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115195426037.png)

属性和api：

- `size`：获取map的长度，`map.size`
- `set`：设置键值对,`map.set(key, val)`
- `get`：返回指定键的值，`map.get(key)`，如果不存在，返回`undefined`
- `has`：判断是否包含某个键值对，`map.has(key)`
- `keys`：返回按插入顺序排序的键的对象，`map.keys()`，格式形如`{ "key1", "key2" }`
- `values`: 返回按插入顺序排序的值的对象，`map.values()`，格式形如`{ "value1", "value" }`
- `delete`：删除指定键值对，`map.delete(key)`
- `clear`：清空map，`map.clear()`
- `forEach`: 遍历map，`map.forEach((value, key) => {})`

#### WeakMap

WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的

属性和api：



#### 扩展：判断一个函数为generaotr函数或者async函数？

`Object.prototype.toString.call`方法，generaotr返回："[object GeneratorFunction]"

`Object.prototype.toString.call`方法，async返回："[object AsyncFunction]"

#### 扩展：Promise中的reject catch和try catch区别

这个实际上问的本质是执行环境栈、宏任务、微任务的错误捕获问题

我们都知道[Event Loop](###Event Loop)，因为我们的代码可能会在三个地方报错，所以有不同的捕获方式：

| 任务类型                 | 捕获方式                                        |
| ------------------------ | ----------------------------------------------- |
| 执行环境栈（call stack） | `try catch`、`window.onerror`                   |
| 宏任务（macrotask）      | `window.onerror`                                |
| 微任务（microtask）      | `window.addEventListener('unhandledrejection')` |

```javascript
	function stack() {
        throw new Error("执行环境栈报错")
    }
    function macroTask() {
        setTimeout(() => {
            throw new Error("宏任务报错")
        }, 0)
    }
    function microTask() {
        Promise.reject("微任务报错")
    }
    window.onerror = function () {
        console.log(...arguments)
    }
    window.addEventListener("unhandledrejection", (err) => {
        console.log(err)
    })
    macroTask()
    microTask()
    stack()
```

#### 扩展：async\await 中的错误处理

最直接的肯定是`try catch`捕获

但是当有多个异步时，就会有很多`try catch`了，所以可以通过将`async`函数用`promise`再封装一层，`resolve` `reject`返回一个数组`[error, data]`，再在外层进行判断是否有`error`分别处理

```javascript
// to.js
export default function to(promise) {
    return promise
        .then(data => {
            return [null, data];
        })
        .catch(err => [err]);
}

// 使用
import to from "./to.js";
async function asyncTask(cb) {
    let err, user, savedTask;

    [err, user] = await to(UserModel.findById(1));
    if (!user) return cb("No user found");

    [err, savedTask] = await to(TaskModel({ userId: user.id, name: "Demo Task" }));
    if (err) return cb("Error occurred while saving task");

    if (user.notificationsEnabled) {
        const [err] = await to(NotificationService.sendNotification(user.id, "Task Created"));
        if (err) return cb("Error while sending notification");
    }

    cb(null, savedTask);
}
```

#### 扩展：Map和WeakMap的区别

- 属性和方法不同：WeakMap没有`size`、`clear`、`forEach`等属性或方法
- 键值区别：WeakMap键值必须为对象，不能为基本数据类型
- 强弱引用区别：WeakMap中键是弱引用的，Map中键是强引用的

关于这两个的强弱引用，我们可以先看两张图：

**WeakMap**

![image-20201115215342615](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115215342615.png)

**Map**

![image-20201115215558451](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201115215558451.png)

第一张是WeakMap的，第二张是Map的，并且Map的size一直有

可以看到，WeakMap中的obj键，在obj这个变量指为null 8s之后，WeakMap就把以obj这个对象的键值对清了；

反之，Map中，则一直保持着obj这个对象的引用，并没有被清



透过现象挖掘本质，这就是强弱引用的区别：

JavaScript的垃圾回收机制：当一个变量不被引用的时候，这片内存就会被回收。

像Object、Map中的键对某个变量的引用为强引用，即使某个变量被释放了，如果这俩玩意儿的键值依然引用着这片地址，那么该变量实际的内存是不会被回收的，这就是强引用。

而WeakMap中的键引用的变量，垃圾回收机制不会考虑你引用了这片内存，过一段时间之后，就会被回收了，这就是弱引用。

什么时候用WeakMap呢？



### 面向对象

#### 原型链 

#### 继承

### Event Loop

## CSS

## HTML

## 计算机网络

### 计算机网络模型

#### OSI参考模型（7层）

应用层、表示层、会话层 、传输层、网络层、数据链路层、物理层

#### TCP/IP参考模型（4层）

应用层、传输层、网络层、数据链路层

#### 5层参考模型

应用层、传输层、网络层、数据链路层、物理层

### HTTPS

### WEB存储

##### cookie

HTTP Cookie，通常被叫做cookie，用于存储客户端的会话信息。

api以及参数：

- `document.cookie`：并不好用，需要自己拼接各项参数，`document.cookie("拼接好的cookie")`
- `name`：cookie名称，不区分大小写，必须经过URL编码
- `value`：cookie值，必须经过URL编码
- `domain`：域，cookie对于哪个域是有效的
- `path`：路径，就是加一个限制条件，同一个域下你可以限制对指定路径发送cookie
- `expires`：生存期，也叫失效时间，表示cookie什么时候过期失效
- `security`：安全标志，表示只有在SSL连接的情况下才会发送

随便打开百度的cookie参考参考：

![image-20201116223955732](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201116223955732.png)

重点：

- 不同浏览器对cookie有数量和大小限制，这个自行查阅
- 由于所有的cookie都会被浏览器作为请求头发送，所以太多cookie肯定会影响http请求的性能
- JavaScript对cookie的操作着实不方便，使用性不是很好

##### sessionStorage

存储特定于某个会话的数据，也就是说该数据只保持该会话关闭为止

api:

- `setItem`：设置数据，`sessionStorage.setItem(key, value)`
- `getItem`：获取数据，`sessionStorage.getItem(key)`
- `removeItem`：删除数据，`sessionStorage.removeItem(key)`
- `clear`：清空数据，`sessionStorage.clear()`

重点：

- sessionStorage局限在同一会话下，所以不能跨浏览器的标签，哪怕是相同域名
- 以chrome浏览器为例，只要还在会话中，不管是普通刷新、ctrl+R、清空缓存并强制刷新，数据依旧保留，直到该会话关闭
- 存在大小限制，大部分浏览器的限制是2.5M

##### localStorage

持久化保存客户端数据，并不局限于会话状态或者浏览器状态

api

- `setItem`：设置数据，`sessionStorage.setItem(key, value)`
- `getItem`：获取数据，`sessionStorage.getItem(key)`
- `removeItem`：删除数据，`sessionStorage.removeItem(key)`
- `clear`：清空数据，`sessionStorage.clear()`

重点：

- 数据的存储范围是在同域名下（子域名也不行）：在知乎保存的localStorage数据，在百度是访问不到的
- 不受刷新、会话状态、浏览器状态影响：关闭会话或者浏览器，下次打开同样的网站，依旧存在
- 存在大小限制，大部分浏览器对每个源的限制是2.5M

### 浏览器缓存

说浏览器缓存之前，我们先大致对缓存有个了解

什么是缓存？

用《图解HTTP》书上的定义是：**缓存是指代理服务器（缓存服务器）或客户端本地磁盘内保存的资源副本**

缓存的种类较多：

- 数据库缓存
- 服务器缓存
- 浏览器缓存
- CDN缓存

与前端最贴近的就是浏览器缓存所以我们只需要重点了解浏览器缓存就行

##### 定义

利用浏览器存储机制，将一部分数据保存在客户端，从而减少对服务器的请求降低服务器的压力，提升性能

##### 位置

##### 分类

浏览器缓存分为**强缓存**和**协商缓存**

在介绍他们的分别之前，我们先来了解一下HTTP的一些首部：

- `Expires`：

  Http/1.0 中的实体首部，包含着资源的过期时间，也就是说，该值之前的时间均返回缓存，之后的时间视为过期，重新获取

- `Cache-Control`：

  Http/1.1 中的通用首部，用于设置缓存策略，下面是几个常用指令：

  `max-age`：设置一个以秒为单位的缓存生存期

  `no-cache`：强制向服务器请求再次验证，为了防止拿到过期的缓存

  `no-store`：不缓存请求或任何响应的内容，直接获取服务器最新的

  

  **当`Cache Control` 和 `Expires`同时出现时，优先处理`Cache Control`**

- `Last-Modified/If-Modified-Since`:

  `Last-Modified`表示的是资源最终被修改的时间

  `If-Modified-Since`是请求首部，表示客户端询问服务器是否在某个时间之后更新过

  配合使用流程：

  第一次获取资源后，服务器会响应该资源最新`Last-Modify`的时间值

  客户端重新请求的时候，会将该时间值作为`If-Modified-Since`的时间值

  服务器在接收到这个参数后，会将该时间和服务器上该资源的最后修改时间比较

  如果没更新过，就返回`304`和`Not Modified`，告知浏览器使用缓存就OK

  如果更新过，那就返回最新的，同时把最新的`Last-Modified`的值更新

- `ETag/If-None-Match`

  `ETag`是资源在服务器上的唯一标识，可以理解为资源的hash值

  `If-None-Match`是请求首部，表示客户端询问服务器某个`ETag`值得资源是否发生过变动

  配合使用流程：

  第一次获取资源后，服务器会响应该资源最新的`ETag`标记值

  客户端后续重新请求时，会将该标记值作为`If-None-Match`的标记值

  服务器在接收到这个参数后，会将该标记和服务器上该资源的最新标记比对

  如果没更新过，就返回`304`和`Not Modified`，告知浏览器使用缓存就OK

  如果更新过，那就返回最新的，同时把最新的`ETag`的值更新
  
  

其实知道了这些首部的作用之后，强缓存和协商缓存就好理解了

**强缓存**

浏览器在请求资源时，会根据HTTP首部的策略来判断是否命中强缓存（是否需要使用本地缓存），这些HTTP首部就是`Expires`、`Cache-Control`

如果使用了缓存，那么就不会向服务器发送请求

所谓强，就是只要能用缓存，就得先用缓存

**协商缓存**

当没有命中强缓存的时候，利用HTTP首部与服务器进行请求交互，判断是否需要使用缓存，这些HTTP首部就是`Last-Modified/If-Modified-Since`、`ETag/If-None-Match`

如果服务器判断资源更新了，那就正常返回新资源，同时更新资源的标记（`Last-Modified`、`ETag`）

如果服务器判断没更新，那就返回`304`和`Not Modified`，告诉浏览器使用缓存

所谓协商，就是客户端和服务器存在一个交互的过程

将上面都理解了之后，看看下面这张图，一切都明白了：



##### 作用

- 减少了冗余的数据传输

- 减少了服务器的负担，大大提升了网站的性能

- 加快了客户端加载网页的速度

##### 影响：

- 缓存没有很好的清理机制，可能会导致用户使用的过期缓存

##### 参考文章

https://segmentfault.com/a/1190000017962411

https://www.jianshu.com/p/9c95db596df5

然后搭配《图解HTTP》，效果极佳

##### 扩展：`Last-Modified/If-Modified-Since` 和 `ETag/If-None-Match`的差别

##### 扩展：浏览器从输入url到页面渲染的过程？

##### 扩展：谈谈对CDN的理解？

CDN（Content Delivery Network）即内容分发网络

## 数据结构

## 算法

#### 动态规划

这类题目看到之后，先分析状态转移方程

## 设计模式

### 观察者模式

当对象间存在一对多关系时，则使用观察者模式（`Observer Pattern`）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

就像老师上课布置作业

### 发布\订阅模式

### 工厂模式

### 单例模式

## 框架

### react

## 前端工程化

## Node

#### 架构



### Koa